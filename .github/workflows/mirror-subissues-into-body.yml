name: Mirror Sub-issues into body
on:
  issues:
    types: [opened, edited, closed, reopened, transferred, labeled, unlabeled, assigned, unassigned]
  workflow_dispatch:
  schedule:
    - cron: "17 */6 * * *"   # периодическая подстраховка

jobs:
  mirror:
    permissions:
      issues: write
      contents: read
    runs-on: ubuntu-latest
    steps:
      - name: Update "Подзадачи" section for current issue and its parent (if any)
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const curNum = context.payload.issue.number;

            // -------- helpers
            async function gql(query, variables) {
              return await github.graphql(query, variables);
            }

            async function getIssueInfo(number) {
              const q = `
                query($owner:String!, $repo:String!, $number:Int!) {
                  repository(owner:$owner, name:$repo) {
                    issue(number:$number) {
                      number
                      title
                      state
                      parent { number repository { nameWithOwner } }
                      subIssues(first: 100) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          number
                          title
                          state
                          assignees(first: 10) { nodes { login } }
                          repository { nameWithOwner }
                        }
                      }
                    }
                  }
                }`;
              const res = await gql(q, { owner, repo, number });
              return res.repository.issue;
            }

            async function getAllSubIssues(number) {
              let issue = await getIssueInfo(number);
              if (!issue) return { parent: null, subs: [] };

              let nodes = issue.subIssues.nodes.slice();
              let cursor = issue.subIssues.pageInfo.endCursor;
              let hasNext = issue.subIssues.pageInfo.hasNextPage;

              while (hasNext) {
                const q = `
                  query($owner:String!, $repo:String!, $number:Int!, $after:String) {
                    repository(owner:$owner, name:$repo) {
                      issue(number:$number) {
                        subIssues(first: 100, after: $after) {
                          pageInfo { hasNextPage endCursor }
                          nodes {
                            number
                            title
                            state
                            assignees(first: 10) { nodes { login } }
                            repository { nameWithOwner }
                          }
                        }
                      }
                    }
                  }`;
                const res = await gql(q, { owner, repo, number, after: cursor });
                const page = res.repository.issue.subIssues;
                nodes.push(...page.nodes);
                cursor = page.pageInfo.endCursor;
                hasNext = page.pageInfo.hasNextPage;
              }

              return { parent: issue.parent, subs: nodes };
            }

            function renderList(items) {
              if (!items.length) {
                return '_Пока нет sub-issues. Используй кнопку **Create sub-issue** ниже описания._';
              }
              // Открытые вверх, затем закрытые; локальные репы — короче запись
              items.sort((a,b) => (a.state === b.state) ? (a.number - b.number) : (a.state === 'OPEN' ? -1 : 1));
              return items.map(si => {
                const box = si.state === 'CLOSED' ? '[x]' : '[ ]';
                const full = si.repository?.nameWithOwner;
                const ref  = full && full.toLowerCase() !== `${owner}/${repo}`.toLowerCase()
                  ? `${full}#${si.number}` : `#${si.number}`;
                const assignees = (si.assignees?.nodes || []).map(n => '@'+n.login).join(', ');
                const tail = assignees ? ` (${assignees})` : '';
                return `- ${box} ${ref} — ${si.title}${tail}`;
              }).join('\n');
            }

            async function updateBodySection(issueNumber, listBlock) {
              const header = '### Подзадачи';
              const startM = '<!-- SUBISSUES-MIRROR:START -->';
              const endM   = '<!-- SUBISSUES-MIRROR:END -->';
              const section = `${header}\n\n${startM}\n${listBlock}\n${endM}\n`;

              const { data: cur } = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
              const body = cur.body || '';

              const blockRe = new RegExp(`${startM}[\\s\\S]*?${endM}`, 'm');
              let newBody;
              if (blockRe.test(body)) {
                newBody = body.replace(blockRe, `${startM}\n${listBlock}\n${endM}`);
              } else {
                const secRe = new RegExp(`(^|\\n)${header}[\\s\\S]*?(?=\\n###\\s|$)`, 'm');
                newBody = secRe.test(body) ? body.replace(secRe, section.trim())
                                           : (body.trim() + '\n\n' + section).trim();
              }

              if (newBody !== body) {
                await github.rest.issues.update({ owner, repo, issue_number: issueNumber, body: newBody });
                core.info(`Issue #${issueNumber}: секция 'Подзадачи' обновлена.`);
              } else {
                core.info(`Issue #${issueNumber}: изменений нет.`);
              }
            }

            // -------- 1) обновим текущий issue (если он сам эпик)
            const { parent, subs } = await getAllSubIssues(curNum);
            await updateBodySection(curNum, renderList(subs));

            // -------- 2) если текущий issue — подзадача, обновим родителя
            if (parent?.number && parent?.repository?.nameWithOwner) {
              const [pOwner, pRepo] = parent.repository.nameWithOwner.split('/');
              // Переключение репо, если родитель в другом репозитории
              const prevOwner = context.repo.owner;
              const prevRepo = context.repo.repo;
              const pNum = parent.number;

              // получим сабы родителя и обновим его
              async function getAllSubIssuesForParent() {
                const q = `
                  query($owner:String!, $repo:String!, $number:Int!) {
                    repository(owner:$owner, name:$repo) {
                      issue(number:$number) {
                        subIssues(first: 100) {
                          pageInfo { hasNextPage endCursor }
                          nodes {
                            number
                            title
                            state
                            assignees(first: 10) { nodes { login } }
                            repository { nameWithOwner }
                          }
                        }
                      }
                    }
                  }`;
                const first = await gql(q, { owner: pOwner, repo: pRepo, number: pNum });
                let nodes = first.repository.issue?.subIssues?.nodes || [];
                let hasNext = first.repository.issue?.subIssues?.pageInfo?.hasNextPage;
                let cursor  = first.repository.issue?.subIssues?.pageInfo?.endCursor;
                while (hasNext) {
                  const q2 = `
                    query($owner:String!, $repo:String!, $number:Int!, $after:String) {
                      repository(owner:$owner, name:$repo) {
                        issue(number:$number) {
                          subIssues(first: 100, after: $after) {
                            pageInfo { hasNextPage endCursor }
                            nodes {
                              number title state
                              assignees(first: 10) { nodes { login } }
                              repository { nameWithOwner }
                            }
                          }
                        }
                      }
                    }`;
                  const page = await gql(q2, { owner: pOwner, repo: pRepo, number: pNum, after: cursor });
                  nodes.push(...page.repository.issue.subIssues.nodes);
                  hasNext = page.repository.issue.subIssues.pageInfo.hasNextPage;
                  cursor  = page.repository.issue.subIssues.pageInfo.endCursor;
                }
                return nodes;
              }

              const pSubs = await getAllSubIssuesForParent();

              // Обновление тела родителя — через REST в его репозитории
              const listBlock = renderList(pSubs);
              const header = '### Подзадачи';
              const startM = '<!-- SUBISSUES-MIRROR:START -->';
              const endM   = '<!-- SUBISSUES-MIRROR:END -->';
              const section = `${header}\n\n${startM}\n${listBlock}\n${endM}\n`;

              const parentIssue = await github.rest.issues.get({ owner: pOwner, repo: pRepo, issue_number: pNum });
              const body = parentIssue.data.body || '';
              const blockRe = new RegExp(`${startM}[\\s\\S]*?${endM}`, 'm');
              let newBody;
              if (blockRe.test(body)) {
                newBody = body.replace(blockRe, `${startM}\n${listBlock}\n${endM}`);
              } else {
                const secRe = new RegExp(`(^|\\n)${header}[\\s\\S]*?(?=\\n###\\s|$)`, 'm');
                newBody = secRe.test(body) ? body.replace(secRe, section.trim())
                                           : (body.trim() + '\n\n' + section).trim();
              }
              if (newBody !== body) {
                await github.rest.issues.update({ owner: pOwner, repo: pRepo, issue_number: pNum, body: newBody });
                core.info(`Родитель ${pOwner}/${pRepo}#${pNum}: секция 'Подзадачи' обновлена.`);
              } else {
                core.info(`Родитель ${pOwner}/${pRepo}#${pNum}: изменений нет.`);
              }
            }
